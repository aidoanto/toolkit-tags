"""
Generate runner.js — a self-contained browser script that:
1. Contains all fill logic from fill_fields.js
2. Contains all page data from page_fields.json, ordered by paths.csv
3. Auto-detects the current page from the URL alias field
4. Clicks the Categories tab
5. Fills all fields
6. Auto-saves if no errors, then navigates to the next page's edit form

Usage:
    uv run generate_runner.py

Output:
    runner.js — paste into the browser console on any Drupal node edit page
"""

import csv
import json
from pathlib import Path

PROJECT_DIR = Path(__file__).parent
PAGE_FIELDS = PROJECT_DIR / "page_fields.json"
PATHS_CSV = PROJECT_DIR / "paths.csv"
OUTPUT = PROJECT_DIR / "runner.js"


def main() -> None:
    # Load page data
    with open(PAGE_FIELDS, encoding="utf-8") as f:
        pages = json.load(f)

    # Build a lookup keyed by drupal_path
    page_by_path: dict[str, dict] = {}
    for page in pages:
        path = page["drupal_path"].strip("/")
        page_by_path[path] = {
            "title": page.get("title", ""),
            "fields": page["fields"],
        }

    # Read paths.csv to get ordering and node IDs
    csv_order: list[dict] = []
    with open(PATHS_CSV, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            drupal_path = row["drupal-path"].strip().strip("/")
            node_id = row.get("node-id", "").strip()
            if drupal_path in page_by_path and node_id:
                csv_order.append({
                    "path": drupal_path,
                    "nid": int(node_id),
                })

    # Build ordered page data with nid
    ordered_pages: list[dict] = []
    for item in csv_order:
        path = item["path"]
        data = page_by_path[path]
        ordered_pages.append({
            "path": path,
            "nid": item["nid"],
            "title": data["title"],
            "fields": data["fields"],
        })

    pages_json = json.dumps(ordered_pages, ensure_ascii=False)

    # Build the runner script
    runner_js = f"""\
/**
 * runner.js — Auto-generated Drupal field filler
 *
 * Paste into the browser console on a node edit page.
 * It will:
 *   1. Detect which page you're on (from the URL alias field)
 *   2. Click the Categories tab
 *   3. Fill all taxonomy fields from the embedded data
 *   4. Auto-save if no errors, then redirect to the next page's edit form
 *
 * Generated by generate_runner.py
 */
(async function() {{
  "use strict";

  // =====================================================================
  // Embedded page data — ordered by paths.csv
  // =====================================================================
  const PAGES = {pages_json};

  // Build a quick lookup by path
  const PAGE_BY_PATH = {{}};
  PAGES.forEach((p, idx) => {{ PAGE_BY_PATH[p.path] = {{ ...p, idx }}; }});

  // =====================================================================
  // Fill logic
  // =====================================================================

  const AUTOCOMPLETE_FIELDS = new Set([
    "field_topics", "field_audience", "field_feelings", "field_access_options",
    "field_quiz_priority", "field_quiz_question_1", "field_quiz_question_2",
    "field_quiz_understanding", "field_helps_with", "field_recommended_topics",
  ]);

  const SELECT_FIELDS = new Set([
    "field_cost", "field_support_toolkit_type", "field_timeframe",
  ]);

  const CHECKBOX_FIELDS = new Set([
    "field_media_type", "field_state", "field_tools_apps_type",
  ]);

  function sleep(ms) {{
    return new Promise(resolve => setTimeout(resolve, ms));
  }}

  function htmlDecode(str) {{
    const txt = document.createElement("textarea");
    txt.innerHTML = str;
    return txt.value;
  }}

  function log(msg) {{
    console.log(`%c[runner] ${{msg}}`, "color: #2196F3; font-weight: bold");
    addStatus(msg);
  }}

  function warn(msg) {{
    console.warn(`[runner] ${{msg}}`);
    addStatus("⚠ " + msg, "orange");
  }}

  let errorCount = 0;
  function error(msg) {{
    errorCount++;
    console.error(`[runner] ${{msg}}`);
    addStatus("✗ " + msg, "red");
  }}

  function waitFor(conditionFn, timeout = 10000, interval = 300) {{
    return new Promise((resolve, reject) => {{
      const start = Date.now();
      const check = () => {{
        const result = conditionFn();
        if (result) resolve(result);
        else if (Date.now() - start > timeout) reject(new Error("waitFor timed out"));
        else setTimeout(check, interval);
      }};
      check();
    }});
  }}

  // --- Status overlay ---
  let statusPanel = document.getElementById("runner-status");
  if (statusPanel) statusPanel.remove();

  statusPanel = document.createElement("div");
  statusPanel.id = "runner-status";
  statusPanel.style.cssText = `
    position: fixed; bottom: 20px; right: 20px; z-index: 99999;
    background: #1a1a2e; color: #eee; padding: 16px 20px;
    border-radius: 10px; font-family: monospace; font-size: 13px;
    max-width: 500px; max-height: 50vh; overflow-y: auto;
    box-shadow: 0 4px 24px rgba(0,0,0,0.4); line-height: 1.6;
  `;
  document.body.appendChild(statusPanel);

  function addStatus(msg, color) {{
    const line = document.createElement("div");
    line.textContent = msg;
    if (color) line.style.color = color;
    statusPanel.appendChild(line);
    statusPanel.scrollTop = statusPanel.scrollHeight;
  }}

  // --- Field wrapper helper ---
  function getFieldWrapper(fieldName) {{
    const cssFieldName = fieldName.replace(/_/g, "-");
    return document.querySelector(`.field--name-${{cssFieldName}}`);
  }}

  // --- Autocomplete ---
  async function resolveAutocompleteValue(input, termName) {{
    const autocompletePath = input.getAttribute("data-autocomplete-path");
    if (!autocompletePath) throw new Error(`No data-autocomplete-path on input ${{input.name}}`);
    const sep = autocompletePath.includes("?") ? "&" : "?";
    const url = `${{autocompletePath}}${{sep}}q=${{encodeURIComponent(termName)}}`;
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Autocomplete fetch failed: ${{response.status}}`);
    const results = await response.json();

    const termLower = termName.toLowerCase().trim();
    const match = results.find(r => htmlDecode(r.label).toLowerCase().trim() === termLower);
    if (match) return match.value;

    const partial = results.find(r => htmlDecode(r.label).toLowerCase().includes(termName.toLowerCase()));
    if (partial) {{
      warn(`No exact match for "${{termName}}", using partial: "${{partial.label}}"`);
      return partial.value;
    }}

    warn(`No autocomplete match for "${{termName}}". Results: ${{JSON.stringify(results.map(r => r.label))}}`);
    return null;
  }}

  async function fillAutocompleteField(fieldName, values) {{
    const wrapper = getFieldWrapper(fieldName);
    if (!wrapper) {{ error(`Field wrapper not found for ${{fieldName}}`); return; }}

    for (let i = 0; i < values.length; i++) {{
      const termName = values[i];

      let input = wrapper.querySelector(`input[name="${{fieldName}}[${{i}}][target_id]"]`);

      if (!input) {{
        const addMoreBtn = wrapper.querySelector('input[type="submit"][value="Add another item"]');
        if (!addMoreBtn) {{ error(`No "Add another item" button for ${{fieldName}}`); return; }}

        log(`  Clicking "Add another item" for ${{fieldName}}...`);
        addMoreBtn.dispatchEvent(new MouseEvent("mousedown", {{ bubbles: true }}));
        addMoreBtn.click();

        try {{
          await waitFor(() => wrapper.querySelector(`input[name="${{fieldName}}[${{i}}][target_id]"]`), 10000);
        }} catch {{
          error(`Timed out waiting for new input row for ${{fieldName}}[${{i}}]`);
          return;
        }}
        await sleep(300);
        input = wrapper.querySelector(`input[name="${{fieldName}}[${{i}}][target_id]"]`);
      }}

      if (!input) {{ error(`Input not found for ${{fieldName}}[${{i}}]`); continue; }}

      if (input.value && input.value.toLowerCase().includes(termName.toLowerCase())) {{
        log(`  ${{fieldName}}[${{i}}] already has "${{termName}}", skipping`);
        continue;
      }}

      const resolvedValue = await resolveAutocompleteValue(input, termName);
      if (!resolvedValue) {{ error(`  Could not resolve "${{termName}}" for ${{fieldName}}`); continue; }}

      input.value = resolvedValue;
      input.dispatchEvent(new Event("input", {{ bubbles: true }}));
      input.dispatchEvent(new Event("change", {{ bubbles: true }}));

      log(`  ${{fieldName}}[${{i}}] = "${{resolvedValue}}"`);
      await sleep(100);
    }}
  }}

  // --- Select fields ---
  async function fillSelectField(fieldName, values) {{
    const wrapper = getFieldWrapper(fieldName);
    if (!wrapper) {{ error(`Field wrapper not found for ${{fieldName}}`); return; }}

    const select = wrapper.querySelector("select");
    if (!select) {{ error(`<select> not found in ${{fieldName}}`); return; }}

    const isMultiple = select.multiple;
    if (isMultiple) {{
      for (const option of select.options) option.selected = false;
    }}

    const effectiveValues = isMultiple ? values : values.slice(0, 1);
    if (!isMultiple && values.length > 1) {{
      warn(`${{fieldName}}: single-select, using first value only ("${{values[0]}}")`);
    }}

    for (const termName of effectiveValues) {{
      let matched = false;
      for (const option of select.options) {{
        if (option.text.trim().toLowerCase() === termName.toLowerCase() ||
            option.value.toLowerCase() === termName.toLowerCase()) {{
          option.selected = true;
          select.value = option.value;
          matched = true;
          log(`  ${{fieldName}}: selected "${{option.text.trim()}}"`);
          break;
        }}
      }}
      if (!matched) {{
        warn(`${{fieldName}}: no option matching "${{termName}}"`);
      }}
    }}

    select.dispatchEvent(new Event("change", {{ bubbles: true }}));
  }}

  // --- Checkbox/radio fields ---
  async function fillCheckboxField(fieldName, values) {{
    const wrapper = getFieldWrapper(fieldName);
    if (!wrapper) {{ error(`Field wrapper not found for ${{fieldName}}`); return; }}

    const checkboxes = wrapper.querySelectorAll('input[type="checkbox"], input[type="radio"]');
    if (checkboxes.length === 0) {{ error(`No checkboxes/radios in ${{fieldName}}`); return; }}

    for (const termName of values) {{
      let matched = false;
      for (const cb of checkboxes) {{
        const label = wrapper.querySelector(`label[for="${{cb.id}}"]`);
        const labelText = label ? label.textContent.trim() : "";
        if (labelText.toLowerCase() === termName.toLowerCase() ||
            cb.value.toLowerCase() === termName.toLowerCase()) {{
          if (!cb.checked) {{
            cb.click();
            log(`  ${{fieldName}}: checked "${{labelText || cb.value}}"`);
          }} else {{
            log(`  ${{fieldName}}: "${{labelText || cb.value}}" already checked`);
          }}
          matched = true;
          break;
        }}
      }}
      if (!matched) {{
        warn(`${{fieldName}}: no checkbox/radio matching "${{termName}}"`);
      }}
    }}
  }}

  // --- Main fill function ---
  async function fillPageFields(fields) {{
    for (const [fieldName, values] of Object.entries(fields)) {{
      if (!values || values.length === 0) continue;
      log(`Filling ${{fieldName}} (${{values.length}} values)...`);
      try {{
        if (AUTOCOMPLETE_FIELDS.has(fieldName)) await fillAutocompleteField(fieldName, values);
        else if (SELECT_FIELDS.has(fieldName)) await fillSelectField(fieldName, values);
        else if (CHECKBOX_FIELDS.has(fieldName)) await fillCheckboxField(fieldName, values);
        else warn(`Unknown field type for ${{fieldName}}, skipping`);
      }} catch (err) {{
        error(`Error filling ${{fieldName}}: ${{err.message}}`);
      }}
      await sleep(200);
    }}
  }}

  // =====================================================================
  // Runner logic
  // =====================================================================

  // 1. Detect current page from URL alias field
  const aliasInput = document.querySelector('input[name="path[0][alias]"]');
  if (!aliasInput) {{
    error("Could not find URL alias field. Are you on a node edit page?");
    return;
  }}

  const alias = aliasInput.value.replace(/^\\//, "").trim();
  log(`Detected page alias: /${{alias}}`);

  const pageInfo = PAGE_BY_PATH[alias];
  if (!pageInfo) {{
    error(`No data found for path: ${{alias}}`);
    error(`This page might not be in page_fields.json, or the alias doesn't match.`);
    return;
  }}

  log(`Page: ${{pageInfo.title}} (#${{pageInfo.idx + 1}} of ${{PAGES.length}})`);
  log(`Fields to fill: ${{Object.keys(pageInfo.fields).join(", ")}}`);

  // 2. Click the Categories tab if not already active
  const categoriesTab = document.querySelector('a[href="#edit-group-categories"]');
  if (categoriesTab) {{
    const isActive = categoriesTab.closest("li")?.classList.contains("is-active") ||
                     categoriesTab.getAttribute("aria-selected") === "true";
    if (!isActive) {{
      log("Clicking Categories tab...");
      categoriesTab.click();
      await sleep(500);
    }} else {{
      log("Categories tab already active");
    }}
  }} else {{
    warn("Categories tab not found — fields might not be visible");
  }}

  // 3. Fill all fields
  const startTime = Date.now();
  await fillPageFields(pageInfo.fields);
  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);

  // 4. Determine next page
  const nextPage = (pageInfo.idx < PAGES.length - 1) ? PAGES[pageInfo.idx + 1] : null;

  // 5. Save + navigate, or show errors
  log(`-----`);

  if (errorCount === 0) {{
    log(`Done in ${{elapsed}}s — no errors.`);
    addStatus(`Progress: ${{pageInfo.idx + 1}} of ${{PAGES.length}}`, "#4CAF50");

    if (nextPage) {{
      log(`Auto-saving, then → ${{nextPage.title}}`);

      // Set Drupal's destination parameter so save redirects to next edit page
      const currentUrl = new URL(window.location.href);
      currentUrl.searchParams.set("destination", `/node/${{nextPage.nid}}/edit`);
      history.replaceState(null, "", currentUrl.toString());
    }} else {{
      log(`Auto-saving (last page!)...`);
    }}

    // Click the sticky Save button
    const saveBtn = document.querySelector("#gin-sticky-edit-submit");
    if (saveBtn) {{
      saveBtn.click();
    }} else {{
      const fallbackBtn = document.querySelector("#edit-submit");
      if (fallbackBtn) fallbackBtn.click();
      else error("Could not find Save button!");
    }}
  }} else {{
    log(`Done in ${{elapsed}}s with ${{errorCount}} error(s). NOT saving — review manually.`);
    if (nextPage) {{
      addStatus(`Next: ${{nextPage.title}} (/node/${{nextPage.nid}}/edit)`, "#4CAF50");
    }}
    addStatus(`Progress: ${{pageInfo.idx + 1}} of ${{PAGES.length}}`, "#4CAF50");
  }}

}})();
"""

    with open(OUTPUT, "w", encoding="utf-8") as f:
        f.write(runner_js)

    print(f"Generated {OUTPUT}")
    print(f"  Pages embedded: {len(ordered_pages)}")
    print(f"  File size: {OUTPUT.stat().st_size:,} bytes")
    print(f"  Order: paths.csv ({len(csv_order)} rows matched)")


if __name__ == "__main__":
    main()
